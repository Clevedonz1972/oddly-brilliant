# Backend Testing Guide

**Last Updated:** 2025-10-27
**Status:** Active Development
**Coverage:** 69/130 tests passing (53%)

═══════════════════════════════════════════════════════════════════════════
## TABLE OF CONTENTS
═══════════════════════════════════════════════════════════════════════════

1. [Running Tests](#running-tests)
2. [Prisma Mock Configuration](#prisma-mock-configuration)
3. [Adding New Tests](#adding-new-tests)
4. [Troubleshooting](#troubleshooting)
5. [Test Coverage Goals](#test-coverage-goals)
6. [Known Issues](#known-issues)

═══════════════════════════════════════════════════════════════════════════
## RUNNING TESTS
═══════════════════════════════════════════════════════════════════════════

### All Tests
```bash
cd backend
npm test
```

### Specific Test File
```bash
npm test -- path/to/file.test.ts

# Example:
npm test -- src/services/__tests__/auth.service.test.ts
```

### Watch Mode
```bash
npm test -- --watch
```

### With Coverage Report
```bash
npm test -- --coverage
```

### Specific Test Suite
```bash
npm test -- --testNamePattern="signup"
```

═══════════════════════════════════════════════════════════════════════════
## PRISMA MOCK CONFIGURATION
═══════════════════════════════════════════════════════════════════════════

### ✅ Correct Pattern (Use This!)

**File:** `src/services/__tests__/example.service.test.ts`

```typescript
import { prisma } from '../../config/database';

// Mock Prisma database module
jest.mock('../../config/database', () => ({
  prisma: {
    users: {  // ← Must match Prisma table name EXACTLY (check schema.prisma)
      findUnique: jest.fn(),
      findMany: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    },
    challenges: {  // Add other tables as needed
      findUnique: jest.fn(),
      findMany: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
    },
    // Add more tables as needed by your tests
  },
}));

describe('ExampleService', () => {
  // Get typed mock reference
  const mockPrismaUser = prisma.users as jest.Mocked<typeof prisma.users>;

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should find user by id', async () => {
    // Arrange
    const mockUser = { id: '123', email: 'test@example.com', /* ... */ };
    mockPrismaUser.findUnique.mockResolvedValue(mockUser as any);

    // Act
    const result = await exampleService.getUserById('123');

    // Assert
    expect(mockPrismaUser.findUnique).toHaveBeenCalledWith({
      where: { id: '123' },
    });
    expect(result).toEqual(mockUser);
  });
});
```

### ❌ Common Mistakes

**Mistake #1: Wrong Table Name**
```typescript
jest.mock('../../config/database', () => ({
  prisma: {
    user: {  // ❌ WRONG - missing 's' (should be 'users')
      findUnique: jest.fn(),
    },
  },
}));
```

**Error:** `TypeError: Cannot read properties of undefined (reading 'findUnique')`

**Fix:** Check `prisma/schema.prisma` for exact table name. Use plural form: `users`, not `user`.

**Mistake #2: Strict Assertion Matching**
```typescript
// ❌ BAD - fails if service adds auto-generated fields
expect(mockPrisma.users.create).toHaveBeenCalledWith({
  data: {
    email: 'test@example.com',
    passwordHash: 'hashed',
    // Missing: id, createdAt, updatedAt (auto-generated by service)
  },
});
```

**Fix:** Use `expect.objectContaining()` for flexible matching:
```typescript
// ✅ GOOD - allows auto-generated fields
expect(mockPrisma.users.create).toHaveBeenCalledWith(
  expect.objectContaining({
    data: expect.objectContaining({
      email: 'test@example.com',
      passwordHash: 'hashed',
    }),
  })
);
```

### Alternative: Manual Mock (Constructor Injection)

**File:** `src/services/__tests__/example.service.test.ts`

```typescript
import { PrismaClient } from '@prisma/client';
import { ExampleService } from '../ExampleService';

describe('ExampleService', () => {
  let mockPrisma: jest.Mocked<PrismaClient>;
  let exampleService: ExampleService;

  beforeEach(() => {
    // Create manual mock
    mockPrisma = {
      users: {
        findUnique: jest.fn(),
        findMany: jest.fn(),
        create: jest.fn(),
      },
    } as any;

    // Inject mock via constructor
    exampleService = new ExampleService(mockPrisma);
    jest.clearAllMocks();
  });

  it('should find user', async () => {
    mockPrisma.users.findUnique.mockResolvedValue({ id: '123' } as any);
    const result = await exampleService.getUser('123');
    expect(result.id).toBe('123');
  });
});
```

**Note:** This approach has TypeScript compilation warnings but tests will run fine. Use `as any` to bypass type checking.

═══════════════════════════════════════════════════════════════════════════
## ADDING NEW TESTS
═══════════════════════════════════════════════════════════════════════════

### Test File Structure

```
backend/src/services/
├── example/
│   ├── ExampleService.ts          # Service implementation
│   └── __tests__/
│       └── ExampleService.test.ts # Tests here
```

### Test File Template

```typescript
import { ExampleService } from '../ExampleService';
import { prisma } from '../../config/database';
import { ValidationError, NotFoundError } from '../../types';

// Mock dependencies
jest.mock('../../config/database', () => ({
  prisma: {
    users: {
      findUnique: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    },
  },
}));

jest.mock('../../utils/logger', () => ({
  logger: {
    info: jest.fn(),
    error: jest.fn(),
    warn: jest.fn(),
  },
}));

describe('ExampleService', () => {
  let exampleService: ExampleService;
  const mockPrismaUser = prisma.users as jest.Mocked<typeof prisma.users>;

  beforeEach(() => {
    exampleService = new ExampleService();
    jest.clearAllMocks();
  });

  describe('methodName()', () => {
    describe('Success Cases', () => {
      it('should do the thing successfully', async () => {
        // Arrange
        const mockData = { /* test data */ };
        mockPrismaUser.findUnique.mockResolvedValue(mockData as any);

        // Act
        const result = await exampleService.methodName();

        // Assert
        expect(result).toEqual(mockData);
        expect(mockPrismaUser.findUnique).toHaveBeenCalledWith({
          where: { /* criteria */ },
        });
      });
    });

    describe('Error Cases', () => {
      it('should throw NotFoundError when not found', async () => {
        // Arrange
        mockPrismaUser.findUnique.mockResolvedValue(null);

        // Act & Assert
        await expect(exampleService.methodName()).rejects.toThrow(NotFoundError);
      });
    });
  });
});
```

### Naming Conventions

- **File:** `ServiceName.test.ts` or `FileName.test.ts`
- **Describe block:** Match service/class name
- **Test descriptions:** Use "should" format
  - ✅ "should return user when ID is valid"
  - ❌ "returns user when ID is valid"
  - ❌ "test get user"

### Test Organization

```typescript
describe('ServiceName', () => {
  describe('methodName()', () => {
    describe('Success Cases', () => {
      it('should handle happy path', () => {});
      it('should handle edge case A', () => {});
    });

    describe('Validation Errors', () => {
      it('should reject invalid input', () => {});
      it('should reject missing field', () => {});
    });

    describe('Error Cases', () => {
      it('should throw NotFoundError', () => {});
      it('should throw AuthorizationError', () => {});
    });
  });
});
```

═══════════════════════════════════════════════════════════════════════════
## TROUBLESHOOTING
═══════════════════════════════════════════════════════════════════════════

### Error: "mockResolvedValue is not a function"

**Symptom:**
```
Property 'mockResolvedValue' does not exist on type '<T extends...>'
```

**Cause:** Mock not properly typed or not created

**Solutions:**
1. Check mock definition uses `jest.fn()`
2. Verify table name matches schema
3. Cast to `jest.Mocked<typeof prisma.tableName>`

```typescript
// ✅ Correct
const mockPrismaUser = prisma.users as jest.Mocked<typeof prisma.users>;
mockPrismaUser.findUnique.mockResolvedValue(data);
```

### Error: "Cannot read properties of undefined (reading 'findUnique')"

**Symptom:**
```
TypeError: Cannot read properties of undefined (reading 'findUnique')
  at ExampleService.method (src/services/example.service.ts:42:55)
```

**Cause:** Mock uses wrong table name

**Solution:**
1. Check `prisma/schema.prisma` for correct table name
2. Update mock to use exact table name:

```typescript
// In schema.prisma:
model users {  // ← Correct name is "users" (plural)
  id String @id
}

// In test file:
jest.mock('../../config/database', () => ({
  prisma: {
    users: {  // ← Must match schema exactly
      findUnique: jest.fn(),
    },
  },
}));
```

### Error: Test expects exact match but service adds fields

**Symptom:**
```
expect(jest.fn()).toHaveBeenCalledWith(...expected)
- Expected
+ Received

  Object {
    "data": Object {
      "email": "test@example.com",
+     "id": "auto-generated-id",
+     "createdAt": 2025-10-27T12:00:00.000Z,
    },
  },
```

**Cause:** Test uses exact object matching, service adds auto-generated fields

**Solution:** Use `expect.objectContaining()`:

```typescript
// ❌ Too strict
expect(mock.create).toHaveBeenCalledWith({
  data: { email: 'test@example.com' },
});

// ✅ Flexible
expect(mock.create).toHaveBeenCalledWith(
  expect.objectContaining({
    data: expect.objectContaining({
      email: 'test@example.com',
    }),
  })
);
```

### Error: "A worker process has failed to exit gracefully"

**Symptom:**
```
A worker process has failed to exit gracefully and has been force exited.
This is likely caused by tests leaking due to improper teardown.
```

**Cause:** Open database connections or timers

**Solution:**
1. Add `afterAll` hook to clean up:

```typescript
afterAll(async () => {
  await prisma.$disconnect();
  jest.clearAllTimers();
});
```

2. Or run with `--detectOpenHandles` to find leaks:
```bash
npm test -- --detectOpenHandles
```

═══════════════════════════════════════════════════════════════════════════
## TEST COVERAGE GOALS
═══════════════════════════════════════════════════════════════════════════

### Current Status (2025-10-27)
- **Total Tests:** 130
- **Passing:** 69 (53%)
- **Failing:** 57 (44%)
- **Skipped:** 4 (3%)

### Coverage by Module

| Module | Tests | Status | Priority |
|--------|-------|--------|----------|
| Auth Service | 29/29 | ✅ 100% | Complete |
| Auth Controller | All | ✅ PASS | Complete |
| Safety Service | All | ✅ PASS | Complete |
| File Service | 0/12 | ❌ 0% | High |
| Proposal Service | Some | ⚠️ Partial | High |
| Submission Service | Some | ⚠️ Partial | Medium |
| Auditor Service | Some | ⚠️ Partial | Medium |
| Event Service | Some | ⚠️ Partial | Low |

### Target Goals
- **Short-term:** 80% tests passing
- **Medium-term:** 90% tests passing
- **Long-term:** 95%+ tests passing
- **Coverage:** 80%+ code coverage

═══════════════════════════════════════════════════════════════════════════
## KNOWN ISSUES
═══════════════════════════════════════════════════════════════════════════

### Issue #029: Prisma Mock Configuration
**Status:** ✅ Partially Resolved (2025-10-27)

**Fixed:**
- ✅ auth.service.test.ts (100% passing)

**Remaining Work:**
- ⚠️ FileService.test.ts - needs mock fix
- ⚠️ ProposalService.test.ts - needs mock fix
- ⚠️ AuditorService.test.ts - needs mock fix
- ⚠️ EventService.test.ts - needs mock fix
- ⚠️ SubmissionService.test.ts - TypeScript errors (non-blocking)

**Pattern for Fix:**
1. Open test file
2. Find `jest.mock('../../config/database')`
3. Check table names against `prisma/schema.prisma`
4. Update mock to use exact table names (plural form usually)
5. Run tests to verify

**Example Fix:**
```typescript
// Before (BROKEN)
jest.mock('../../config/database', () => ({
  prisma: {
    file: {  // ❌ Wrong - should be file_artifacts
      findUnique: jest.fn(),
    },
  },
}));

// After (FIXED)
jest.mock('../../config/database', () => ({
  prisma: {
    file_artifacts: {  // ✅ Matches schema
      findUnique: jest.fn(),
    },
  },
}));
```

### TypeScript Compilation Errors in Tests
**Status:** ⚠️ Known Issue (Non-blocking)

**Affected:** SubmissionService.test.ts

**Impact:** Cosmetic only - tests run fine despite errors

**Cause:** Manual mocks use `as any` which bypasses type checking

**Solution:** Optional - create proper mock types, or leave as-is

═══════════════════════════════════════════════════════════════════════════
## RESOURCES
═══════════════════════════════════════════════════════════════════════════

### Documentation
- [Jest Documentation](https://jestjs.io/docs/getting-started)
- [Prisma Testing Guide](https://www.prisma.io/docs/guides/testing)
- [TypeScript Jest](https://kulshekhar.github.io/ts-jest/)

### Project Files
- Test Configuration: `backend/jest.config.js`
- Prisma Schema: `backend/prisma/schema.prisma`
- Test Files: `backend/src/**/__tests__/**/*.test.ts`

### Commands Reference
```bash
# Run all tests
npm test

# Run specific file
npm test -- path/to/file.test.ts

# Watch mode
npm test -- --watch

# Coverage report
npm test -- --coverage

# Find open handles
npm test -- --detectOpenHandles

# Run tests matching pattern
npm test -- --testNamePattern="should find user"
```

═══════════════════════════════════════════════════════════════════════════
## CHANGELOG
═══════════════════════════════════════════════════════════════════════════

### 2025-10-27
- Created TESTING-GUIDE.md
- Fixed auth.service.test.ts (29/29 tests passing)
- Documented Prisma mock pattern
- Identified remaining test files needing fixes
- Current status: 69/130 tests passing (53%)
